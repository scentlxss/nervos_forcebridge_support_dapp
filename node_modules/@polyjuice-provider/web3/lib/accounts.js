"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcPolyjuiceTxHash = exports.TxConfigValueTypeToString = exports.formatEthTransaction = exports.transactionConfigToPolyjuiceEthTransaction = exports.PolyjuiceAccounts = void 0;
const base_1 = require("@polyjuice-provider/base");
const account_1 = __importDefault(require("eth-lib/lib/account"));
const base_2 = require("@ckb-lumos/base");
const godwoken_1 = require("@polyjuice-provider/godwoken");
const schemas_1 = require("@polyjuice-provider/godwoken/schemas");
// do not change the following require to import, otherwise it will cause error.
// the original web3-eth-accounts Account class is exported by module.exports.
const Accounts = require("web3-eth-accounts");
class PolyjuiceAccounts extends Accounts {
    constructor(polyjuiceConfig, provider) {
        if (provider) {
            super(provider);
        }
        else {
            super();
        }
        if (!polyjuiceConfig.web3Url) {
            throw new Error("should support web3 rpc url in PolyjuiceConfig.");
        }
        const godwokerOption = {
            godwoken: {
                rollup_type_hash: polyjuiceConfig.rollupTypeHash,
                eth_account_lock: {
                    code_hash: polyjuiceConfig.ethAccountLockCodeHash,
                    hash_type: "type",
                },
            },
        };
        this.godwoker = new base_1.Godwoker(polyjuiceConfig.web3Url, godwokerOption);
        this.abi = new base_1.Abi(polyjuiceConfig.abiItems || []);
    }
    setAbi(abiItems) {
        this.abi = new base_1.Abi(abiItems);
    }
    signTransaction(_tx, privateKey, callback) {
        const that = this;
        callback = callback || function () { };
        if (!_tx) {
            const error = new Error("No transaction object given!");
            callback(error);
            return Promise.reject(error);
        }
        if (!_tx.from) {
            _tx.from = this.privateKeyToAccount(privateKey).address;
        }
        // use godwoken-polyjuice's transaction signing method
        // (which is deifferent tx structure and use a message signing)
        // to sign transaction.
        let tx = transactionConfigToPolyjuiceEthTransaction(_tx);
        try {
            // Otherwise, get the missing info from the Ethereum Node
            return Promise.all([
                this.godwoker.assembleRawL2Transaction(tx),
                this.godwoker.generateMessageFromEthTransaction(tx),
            ]).then(function (args) {
                if (!args[0] || !args[1]) {
                    const error = new Error("assembleRawL2Transaction or generateMessageFromEthTransaction is failed.");
                    callback(error);
                    return Promise.reject(error);
                }
                const polyjuice_tx = args[0];
                const message = args[1];
                const _signature = account_1.default.sign(message, privateKey);
                const signature = that.godwoker.packSignature(_signature);
                const l2_tx = { raw: polyjuice_tx, signature: signature };
                let result = {
                    messageHash: message,
                    v: "0x0",
                    r: "0x0",
                    s: signature,
                    rawTransaction: that.godwoker.serializeL2Transaction(l2_tx),
                    transactionHash: calcPolyjuiceTxHash(polyjuice_tx),
                };
                callback(null, result);
                return Promise.resolve(result);
            });
        }
        catch (error) {
            callback(error);
            return Promise.reject(error);
        }
    }
}
exports.PolyjuiceAccounts = PolyjuiceAccounts;
function transactionConfigToPolyjuiceEthTransaction(tx) {
    let { from, to, value, gas, gasPrice, data, nonce } = tx;
    if (!from) {
        throw new Error("from is missing!");
    }
    if (typeof from === "number") {
        //todo: handle from is number
        throw new Error("todo: handle from is number case!");
    }
    return formatEthTransaction({ from, to, value, gas, gasPrice, data, nonce });
}
exports.transactionConfigToPolyjuiceEthTransaction = transactionConfigToPolyjuiceEthTransaction;
// todo: remove to @polyjuice-provider/base
function formatEthTransaction({ from, to, value, gas, gasPrice, data, nonce, }) {
    const ethTx = {
        from: from,
        to: base_1.formalizeEthToAddress(to),
        value: value ? TxConfigValueTypeToString(value) : "0x00",
        gas: gas
            ? TxConfigValueTypeToString(gas)
            : `0x${BigInt(base_1.POLY_MAX_TRANSACTION_GAS_LIMIT).toString(16)}`,
        gasPrice: gasPrice
            ? TxConfigValueTypeToString(gasPrice)
            : `0x${BigInt(base_1.POLY_MIN_GAS_PRICE).toString(16)}`,
        data: data ? TxConfigValueTypeToString(data) : "0x00",
        nonce: nonce ? TxConfigValueTypeToString(nonce) : "0x1",
    };
    return ethTx;
}
exports.formatEthTransaction = formatEthTransaction;
function TxConfigValueTypeToString(value) {
    if (typeof value === "string") {
        value = "0x" + BigInt(value).toString(16);
    }
    if (typeof value === "number") {
        value = "0x" + BigInt(value).toString(16);
    }
    if (typeof value !== "string" || typeof value !== "number") {
        // BN.js type
        value = value.toString(16);
    }
    return value;
}
exports.TxConfigValueTypeToString = TxConfigValueTypeToString;
// todo: move to @polyjuice-provider/godwoken
function calcPolyjuiceTxHash(tx) {
    const tx_hash = base_2.utils
        .ckbHash(schemas_1.SerializeRawL2Transaction(godwoken_1.normalizer.NormalizeRawL2Transaction(tx)))
        .serializeJson();
    return tx_hash;
}
exports.calcPolyjuiceTxHash = calcPolyjuiceTxHash;
//# sourceMappingURL=accounts.js.map