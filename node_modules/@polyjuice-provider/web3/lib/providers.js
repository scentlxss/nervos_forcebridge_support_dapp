"use strict";
/**
 * this file is a custom http provider used to proxy ETH rpc call to godwoken-polyjuice chain.
 * it is fork and based on https://github.com/ChainSafe/web3.js/tree/1.x/packages/web3-providers-http
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolyjuiceHttpProvider = void 0;
const http = __importStar(require("http"));
const https = __importStar(require("https"));
const web3_core_helpers_1 = require("web3-core-helpers");
const xhr2_cookies_1 = require("xhr2-cookies");
const base_1 = require("@polyjuice-provider/base");
class PolyjuiceHttpProvider {
    constructor(host, polyjuice_config, options) {
        this.signer = new base_1.Signer();
        const godwoker_option = {
            godwoken: {
                rollup_type_hash: polyjuice_config.rollupTypeHash,
                eth_account_lock: {
                    code_hash: polyjuice_config.ethAccountLockCodeHash,
                    hash_type: "type",
                },
            },
        };
        this.godwoker = new base_1.Godwoker(host, godwoker_option);
        this.abi = new base_1.Abi(polyjuice_config.abiItems || []);
        options = options || {};
        this.withCredentials = options.withCredentials || false;
        this.timeout = options.timeout || 0;
        this.headers = options.headers;
        this.agent = options.agent;
        this.connected = false;
        // keepAlive is true unless explicitly set to false
        const keepAlive = options.keepAlive !== false;
        this.host = host || "http://localhost:8024";
        if (!this.agent) {
            if (this.host.substring(0, 5) === "https") {
                this.httpsAgent = new https.Agent({ keepAlive });
            }
            else {
                this.httpAgent = new http.Agent({ keepAlive });
            }
        }
    }
    setAbi(abiItems) {
        this.abi = new base_1.Abi(abiItems);
    }
    async send(payload, callback) {
        const { method, params } = payload;
        switch (method) {
            case "eth_sendRawTransaction":
                // todo: forbidden normal eth raw tx pass.
                try {
                    const tx_hash = await this.godwoker.gw_submitSerializedL2Transaction(params[0]);
                    callback(null, {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        result: tx_hash,
                    });
                }
                catch (error) {
                    callback(null, {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        error: error.message,
                    });
                }
                break;
            case "eth_sendTransaction":
                try {
                    const { from, gas, gasPrice, value, data } = params[0];
                    const to = base_1.formalizeEthToAddress(params[0].to);
                    const data_with_short_address = await this.abi.refactor_data_with_short_address(data, this.godwoker.getShortAddressByAllTypeEthAddress.bind(this.godwoker));
                    const t = {
                        from: from,
                        to: to,
                        value: value || 0,
                        data: data_with_short_address || "",
                        gas: gas,
                        gasPrice: gasPrice,
                    };
                    const to_id = await this.godwoker.allTypeEthAddressToAccountId(to);
                    const sender_script_hash = this.godwoker.computeScriptHashByEoaEthAddress(from);
                    const receiver_script_hash = await this.godwoker.getScriptHashByAccountId(parseInt(to_id));
                    const polyjuice_tx = await this.godwoker.assembleRawL2Transaction(t);
                    const message = this.godwoker.generateTransactionMessageToSign(polyjuice_tx, sender_script_hash, receiver_script_hash);
                    const _signature = await this.signer.sign_with_metamask(message, from);
                    const signature = this.godwoker.packSignature(_signature);
                    const tx_hash = await this.godwoker.gw_submitL2Transaction(polyjuice_tx, signature);
                    await this.godwoker.waitForTransactionReceipt(tx_hash);
                    const res = {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        result: tx_hash,
                    };
                    callback(null, res);
                }
                catch (error) {
                    callback(null, {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        error: error.message,
                    });
                }
                break;
            case "eth_call":
                try {
                    const { from, gas, gasPrice, value, data, to } = params[0];
                    const data_with_short_address = await this.abi.refactor_data_with_short_address(data, this.godwoker.getShortAddressByAllTypeEthAddress.bind(this.godwoker));
                    const t = {
                        from: from || (await this.godwoker.getPolyjuiceDefaultFromAddress()),
                        to: to,
                        value: value || 0,
                        data: data_with_short_address || "",
                        gas: gas || base_1.POLY_MAX_TRANSACTION_GAS_LIMIT,
                        gasPrice: gasPrice || base_1.POLY_MIN_GAS_PRICE,
                    };
                    const polyjuice_tx = await this.godwoker.assembleRawL2Transaction(t);
                    const run_result = await this.godwoker.gw_executeRawL2Transaction(polyjuice_tx);
                    const abi_item = this.abi.get_intereted_abi_item_by_encoded_data(data);
                    if (!abi_item) {
                        const res = {
                            jsonrpc: payload.jsonrpc,
                            id: payload.id,
                            result: run_result.return_data,
                        };
                        callback(null, res);
                    }
                    else {
                        const return_value_with_short_address = await this.abi.refactor_return_value_with_short_address(run_result.return_data, abi_item, this.godwoker.getEthAddressByAllTypeShortAddress.bind(this.godwoker));
                        const res = {
                            jsonrpc: payload.jsonrpc,
                            id: payload.id,
                            result: return_value_with_short_address,
                        };
                        callback(null, res);
                    }
                }
                catch (error) {
                    callback(null, {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        error: error.message,
                    });
                }
                break;
            case "eth_estimateGas":
                try {
                    let new_payload = payload;
                    const { data } = params[0];
                    const data_with_short_address = await this.abi.refactor_data_with_short_address(data, this.godwoker.getShortAddressByAllTypeEthAddress.bind(this.godwoker));
                    new_payload.params[0].data = data_with_short_address;
                    new_payload.params[0].from =
                        new_payload.params[0].from ||
                            (await this.godwoker.getPolyjuiceDefaultFromAddress());
                    this._send(new_payload, callback);
                }
                catch (error) {
                    callback(null, {
                        jsonrpc: payload.jsonrpc,
                        id: payload.id,
                        error: error.message,
                    });
                }
                break;
            default:
                this._send(payload, callback);
                break;
        }
    }
    _prepareRequest() {
        let request;
        // the current runtime is a browser
        if (typeof XMLHttpRequest !== "undefined") {
            request = new XMLHttpRequest();
        }
        else {
            request = new xhr2_cookies_1.XMLHttpRequest();
            let agents = {
                httpsAgent: this.httpsAgent,
                httpAgent: this.httpAgent,
                baseUrl: this.baseUrl,
            };
            if (this.agent) {
                agents.httpsAgent = this.agent.https;
                agents.httpAgent = this.agent.http;
                agents.baseUrl = this.agent.baseUrl;
            }
            request.nodejsSet(agents);
        }
        request.open("POST", this.host, true);
        request.setRequestHeader("Content-Type", "application/json");
        request.timeout = this.timeout;
        request.withCredentials = this.withCredentials;
        if (this.headers) {
            this.headers.forEach(function (header) {
                request.setRequestHeader(header.name, header.value);
            });
        }
        return request;
    }
    /**
     * Should be used to make async request
     *
     * @method send
     * @param {Object} payload
     * @param {Function} callback triggered on end with (err, result)
     */
    _send(payload, callback) {
        let _this = this;
        let request = this._prepareRequest();
        request.onreadystatechange = function () {
            if (request.readyState === 4 && request.timeout !== 1) {
                let result = request.responseText;
                let error = null;
                try {
                    result = JSON.parse(result);
                }
                catch (e) {
                    error = web3_core_helpers_1.errors.InvalidResponse(request.responseText);
                }
                _this.connected = true;
                callback(error, result);
            }
        };
        request.ontimeout = function () {
            _this.connected = false;
            callback(web3_core_helpers_1.errors.ConnectionTimeout(this.timeout));
        };
        try {
            request.send(JSON.stringify(payload));
        }
        catch (error) {
            this.connected = false;
            callback(web3_core_helpers_1.errors.InvalidConnection(this.host));
        }
    }
    /**
     * Returns the desired boolean.
     *
     * @method supportsSubscriptions
     * @returns {boolean}
     */
    supportsSubscriptions() {
        return false;
    }
    disconnect() {
        return this.connected;
    }
}
exports.PolyjuiceHttpProvider = PolyjuiceHttpProvider;
//# sourceMappingURL=providers.js.map