"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytesToHex = exports.hexToBytes = exports.toUint64Le = exports.toUint32Le = exports.toUint16Le = void 0;
const validators_1 = require("../validators");
const exceptions_1 = require("../exceptions");
exports.toUint16Le = (uint16) => {
    validators_1.assertToBeHexStringOrBigint(uint16);
    const dv = new DataView(new ArrayBuffer(2));
    dv.setUint16(0, Number(uint16), true);
    return `0x${dv.getUint16(0, false).toString(16).padStart(4, '0')}`;
};
exports.toUint32Le = (uint32) => {
    validators_1.assertToBeHexStringOrBigint(uint32);
    const dv = new DataView(new ArrayBuffer(4));
    dv.setUint32(0, Number(uint32), true);
    return `0x${dv.getUint32(0, false).toString(16).padStart(8, '0')}`;
};
exports.toUint64Le = (uint64) => {
    validators_1.assertToBeHexStringOrBigint(uint64);
    const val = (typeof uint64 === 'bigint' ? uint64.toString(16) : uint64.slice(2)).padStart(16, '0');
    const viewRight = exports.toUint32Le(`0x${val.slice(0, 8)}`).slice(2);
    const viewLeft = exports.toUint32Le(`0x${val.slice(8)}`).slice(2);
    return `0x${viewLeft}${viewRight}`;
};
exports.hexToBytes = (rawhex) => {
    if (rawhex === '')
        return new Uint8Array();
    if (typeof rawhex === 'string' && !rawhex.startsWith('0x')) {
        throw new exceptions_1.HexStringWithout0xException(rawhex);
    }
    let hex = rawhex.toString(16).replace(/^0x/i, '');
    hex = hex.length % 2 ? `0${hex}` : hex;
    const bytes = [];
    for (let c = 0; c < hex.length; c += 2) {
        bytes.push(parseInt(hex.substr(c, 2), 16));
    }
    return new Uint8Array(bytes);
};
exports.bytesToHex = (bytes) => `0x${[...bytes].map(b => b.toString(16).padStart(2, '0')).join('')}`;
exports.default = {
    toUint16Le: exports.toUint16Le,
    toUint32Le: exports.toUint32Le,
    toUint64Le: exports.toUint64Le,
    hexToBytes: exports.hexToBytes,
    bytesToHex: exports.bytesToHex,
};
//# sourceMappingURL=index.js.map