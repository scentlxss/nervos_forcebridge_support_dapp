"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addressToScript = exports.parseAddress = exports.pubkeyToAddress = exports.fullPayloadToAddress = exports.bech32Address = exports.toAddressPayload = exports.AddressType = exports.AddressPrefix = void 0;
const __1 = require("..");
const systemScripts_1 = require("../systemScripts");
const convertors_1 = require("../convertors");
const exceptions_1 = require("../exceptions");
var AddressPrefix;
(function (AddressPrefix) {
    AddressPrefix["Mainnet"] = "ckb";
    AddressPrefix["Testnet"] = "ckt";
})(AddressPrefix = exports.AddressPrefix || (exports.AddressPrefix = {}));
var AddressType;
(function (AddressType) {
    AddressType["HashIdx"] = "0x01";
    AddressType["DataCodeHash"] = "0x02";
    AddressType["TypeCodeHash"] = "0x04";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
exports.toAddressPayload = (args, type = AddressType.HashIdx, codeHashOrCodeHashIndex = '0x00') => {
    if (typeof args === 'string') {
        if (!args.startsWith('0x')) {
            throw new exceptions_1.HexStringWithout0xException(args);
        }
        return new Uint8Array([...convertors_1.hexToBytes(type), ...convertors_1.hexToBytes(codeHashOrCodeHashIndex), ...convertors_1.hexToBytes(args)]);
    }
    return new Uint8Array([...convertors_1.hexToBytes(type), ...convertors_1.hexToBytes(codeHashOrCodeHashIndex), ...args]);
};
exports.bech32Address = (args, { prefix = AddressPrefix.Mainnet, type = AddressType.HashIdx, codeHashOrCodeHashIndex = '0x00' } = {}) => __1.bech32.encode(prefix, __1.bech32.toWords(exports.toAddressPayload(args, type, codeHashOrCodeHashIndex)));
exports.fullPayloadToAddress = ({ args, prefix, type = AddressType.DataCodeHash, codeHash, }) => exports.bech32Address(args, { prefix, type, codeHashOrCodeHashIndex: codeHash });
exports.pubkeyToAddress = (pubkey, options = {}) => {
    const publicKeyHash = __1.blake160(pubkey);
    return exports.bech32Address(publicKeyHash, options);
};
const isValidShortVersionPayload = (payload) => {
    const [, index, ...data] = payload;
    switch (index) {
        case 0:
        case 1: {
            if (data.length !== 20) {
                throw new exceptions_1.AddressPayloadException(payload, 'short');
            }
            break;
        }
        case 2: {
            if (data.length === 20 || data.length === 22 || data.length === 24) {
                break;
            }
            throw new exceptions_1.AddressPayloadException(payload, 'short');
        }
        default: {
            throw new exceptions_1.AddressPayloadException(payload, 'short');
        }
    }
};
const isValidPayload = (payload) => {
    const [type, ...data] = payload;
    switch (type) {
        case +AddressType.HashIdx: {
            isValidShortVersionPayload(payload);
            break;
        }
        case +AddressType.DataCodeHash:
        case +AddressType.TypeCodeHash: {
            if (data.length < 32) {
                throw new exceptions_1.AddressPayloadException(payload, 'full');
            }
            break;
        }
        default: {
            throw new exceptions_1.AddressPayloadException(payload);
        }
    }
};
exports.parseAddress = (address, encode = 'binary') => {
    const decoded = __1.bech32.decode(address);
    const payload = __1.bech32.fromWords(new Uint8Array(decoded.words));
    try {
        isValidPayload(payload);
    }
    catch (err) {
        throw new exceptions_1.AddressException(address, err.type);
    }
    return encode === 'binary' ? payload : convertors_1.bytesToHex(payload);
};
exports.addressToScript = (address) => {
    const payload = exports.parseAddress(address);
    const type = payload[0];
    if (type === +AddressType.HashIdx) {
        const codeHashIndices = [
            systemScripts_1.SECP256K1_BLAKE160,
            systemScripts_1.SECP256K1_MULTISIG,
            address.startsWith(AddressPrefix.Mainnet) ? systemScripts_1.ANYONE_CAN_PAY_MAINNET : systemScripts_1.ANYONE_CAN_PAY_TESTNET,
        ];
        const index = payload[1];
        const args = payload.slice(2);
        const script = codeHashIndices[index];
        return {
            codeHash: script.codeHash,
            hashType: script.hashType,
            args: convertors_1.bytesToHex(args),
        };
    }
    const codeHashAndArgs = convertors_1.bytesToHex(payload.slice(1));
    const hashType = type === +AddressType.DataCodeHash ? 'data' : 'type';
    return {
        codeHash: codeHashAndArgs.substr(0, 66),
        hashType,
        args: `0x${codeHashAndArgs.substr(66)}`,
    };
};
//# sourceMappingURL=index.js.map